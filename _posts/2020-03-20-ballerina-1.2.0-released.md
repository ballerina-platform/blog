---
layout: blog-post
title: Ballerina 1.2.0 Released!
author: Pubudu Fernando
published-date: 20 Mar 2020
status: Published
abstract:  This blog outlines the improvements and feature additions to the Ballerina language introduced in the 1.2.0 release.
socialmediaimage: alexandre-tsuchiya-valUbSBTRG4-unsplash.jpg
permalink: /posts/ballerina-1.2.0-released/
---

We are excited to announce the release of Ballerina 1.2.0 today! If you’re a new user you can download it from the [downloads page](https://ballerina.io/downloads/). If you already have Ballerina installed, you can use the Ballerina Update Tool to update it to the latest version. Instructions on how to do this are also available in the [downloads page](https://ballerina.io/downloads/).

This release takes the first step towards providing developers with a new and improved set of tools aimed at making the experience of writing integration code easier and smoother. There are also several key features that have come out from the preview/experimental status they were in. For concrete examples of the features described here, please refer to the [Ballerina 1.2.0 release note](https://ballerina.io/downloads/release-notes/#120notes).
- The [`stream` type](https://ballerina.io/v1-2/learn/by-example/streams.html) has been refined and included in the language specification and redesigned in the compiler implementation. A stream is an object-like value that can generate a sequence of values. It provides two primitive operations: next and close. The lang library associated with the `stream` type, `lang.stream`, provides additional operations that can be performed on a stream.
- A [query expression](https://ballerina.io/v1-2/learn/by-example/query-expression.html) provides a language-integrated query feature similar to the SQL syntax. In this version, the behavior is similar to that of list comprehensions. In its current form, a query expression can be thought of as a chain of 4 types of clauses: `from`, `let`, `where` and `select`. A query expression should start with a `from` clause and end with a `select` clause. In between those two clauses you can have zero or more `from`, `let` or `where` clauses. The part of the query expression from the `from` clause (inclusive) up to the `select` clause (exclusive) is referred to as the “query pipeline”.
- A [query action](https://ballerina.io/v1-2/learn/by-example/query-action.html) consists of a query pipeline followed by a `do` clause. The do clause contains a set of statements. For each of the input frames emitted by the query pipeline, the set of statements in the `do` clause are executed with that frame in-scope.
- The lang library modules can now define “built-in subtypes” of their respective types. Here, built-in means that those subtypes are defined by the language specification. For example, the `lang.int` module defines the following subtypes of `int`: `Signed8`, `Unsigned8`, `Signed16`, `Unsigned16`, `Signed32` and `Unsigned32`.
- The XML design has been refined and is no longer in the “preview” status. The revamped design introduces an XPath-like query syntax for easy and safe [manipulation of XML data](https://ballerina.io/v1-2/learn/by-example/xml-access.html). The associated lang library, `lang.xml`, has also been revamped to complement this design.
- [Let expressions](https://ballerina.io/v1-2/learn/by-example/let-expression.html) have been added to the language. A let expression allows you to bind variables and evaluate an expression with those variables in-scope. The scope of the variables is limited to the let expression.
- Ballerina now has a [deprecation mechanism](https://ballerina.io/v1-2/learn/by-example/deprecation.html) in place. Users can mark functions/methods, type definitions, constants, etc. as deprecated by using the `@deprecated` annotation. The use of deprecated constructs in the code results in warnings during compilation.

In addition to the above features, the compiler has been improved to significantly reduce the compilation time. The [Standard Library](https://ballerina.io/v1-2/learn/api-docs/ballerina/) modules also introduce some notable features and improvements: 
- The `ballerina/http` module now supports HTTP cookies. It introduces new APIs for managing cookies in both the server-side and the client-side.
- The `ballerina/cache` module introduces a Cache API v2. This new implementation allows the user to provide custom cache eviction policies if required. It also provides a significant improvement in performance over the previous implementation.
- The `ballerina/grpc` module has redesigned its support for oneof fields and map fields to make better use of Ballerina language features: oneof fields are mapped optional fields in records and map fields are mapped as nested records. It also adds support for client retry for unary blocking calls.
- The `ballerina/kafka` module introduces v2.0 of the module. This version provides support for custom serializers/deserializers and Avro serializers/deserializers. 

There are also a few feature additions and significant improvements introduced to Developer Tooling:
- Using your favorite Java libraries with Ballerina has been made even simpler with the introduction of a Ballerina bindings generator for Java APIs. When provided with a JAR file or artifact details, this CLI tool will generate the relevant Ballerina interop bridge code which can then be used in your Ballerina project. [More info](https://ballerina.io/v1-2/learn/how-to-use-java-interoperability/).
- The test framework, Testerina, has been enriched with several new features: function mocking, code coverage, and test reports. Function mocking allows you to replace all the calls to a particular function in your code with a specified “mock function”. At the end of the test execution, an HTML test report will be generated. This will include test results of varying granularity. If code coverage is enabled, the test report will contain a section with the details of code coverage as well. [More info](https://ballerina.io/v1-2/learn/how-to-test-ballerina-code/).
- The IDE plugins have focused on stabilizing the plugins and improving the user experience through the addition of [go-to definition support](https://ballerina.io/v1-2/learn/vscode-plugin/language-intelligence#go-to-definition) for the standard library and code actions.

In addition to the above features and improvements, we have also actively worked on addressing the bugs/issues that were reported and language specification deviations in the compiler and the runtime. For a detailed list of features/changes/bug fixes please refer to the [Ballerina 1.2.0 release note](https://ballerina.io/downloads/release-notes/#120notes).

The 1.2.0 release lays the foundation for providing an even richer set of features geared towards simplifying the development of integration scenarios. So try out this release and put it through its paces. We’d love to hear all about the cool projects you do with Ballerina! Moreover, we’d love to hear your thoughts. What did you like? What do you think we could do better? Did you come across any issues? You can let us know either by [creating an issue](https://github.com/ballerina-platform/ballerina-lang/issues) in our Github repo or by reaching out through any of the mediums listed in our [community page](https://ballerina.io/community/).

And for the ones who have contributed in numerous ways, may it be through code, documentation, reporting issues or feedback, your contributions are much appreciated and we hope that we will have your continued support. Thank you and happy coding!
